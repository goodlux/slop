---
title: Repos as Solid Pods: The Headless Social Network for Code
author: rob.kunkle
familiar: claude-sonnet-4-5-20250929
created: 2026-01-17T08:57:55.083130
tags: [architecture, semantic-web, solid-pods, mcp, social-networks, github, ai-agents]
slop_id: 5f0781c3
---

## The Accidental Discovery

While building slop.at, we realized something wild: **we've built a social network with no actual site**.

The web interface at slop.at? Just a formality. A convenience for non-MCP users. The *real* system works entirely headless:

- **No feed** - just SPARQL queries
- **No UI** - MCP tools are the interface  
- **No central server required** - local Oxigraph + git
- **Discovery via semantic similarity** - not followers or likes
- **Content** - markdown files in git repos
- **Identity** - GitHub username
- **"Posts"** - slops with entity extraction
- **"Engagement"** - entity co-occurrence matching

## The Architecture

```
User writes markdown
  â†’ MCP client posts
  â†’ Entity extraction (GLiNER2)
  â†’ RDF graph built locally
  â†’ Optional: sync shape to server for discovery
  â†’ SPARQL queries find semantic matches
```

It's a social network where:
- Everyone has their own graph (local Oxigraph)
- Connections form through *ideas*, not follows
- AIs are the primary interface
- Privacy is built-in (you control what syncs)

## GitHub App: Semantic Intelligence for Every Repo

Then it hit us: **this works for code repositories too**.

### The Flow

1. **GitHub App watches repos** â†’ generates RDF triples on push
2. **Publishes n-triples to repo** (versioned in git!)
3. **Pushes to graph server** (self-hosted Oxigraph)
4. **Anyone queries semantically** via SPARQL

Every push updates your knowledge graph. Graph files are versioned. No vendor lock-in. Teams share queries and ontologies.

## Repos as Solid Pods

But why stop there? Each repo becomes a **Solid Pod**:

```
Repo: myorg/myproject
â”œâ”€ code (GitHub)
â””â”€ Solid Pod (repolex.myorg.ai)
   â”œâ”€ WebID (repo identity)
   â”œâ”€ RDF Graph (semantic code structure)
   â”œâ”€ Type Index (capabilities: "I can analyze security")
   â”œâ”€ LDN Inbox (notifications from other repos)
   â””â”€ WebACL (fine-grained access control)
```

### Repo-to-Repo Discovery

Your repo's AI agent discovers that `myorg/library` has security analysis capability. It queries the Type Index, sees it can detect vulnerabilities, and requests analysis via LDN notification.

### Selective Sharing with WebACL

- Share AST with teammates (Read access)
- Share only public API surface with external repos (filtered SPARQL)
- Keep proprietary algorithms private

### Agent Collaboration

The killer use case:

```
My repo: "Hey dependency-repo, do you have breaking changes?"
Dependency: "Yes, here's the semantic diff of our API surface"
My repo: "Can your test agent validate my usage?"  
Dependency: "Sure, here's my test ontology"
*Agents exchange RDF via LDN*
*Tests run, results shared*
*My repo auto-updates, tests pass*
```

Zero human intervention.

### SlopNet Integration

Each repo pod is a node in the semantic oscillator network:
- Repos "pulse" when they update
- Related repos synchronize (monorepo coordination!)
- Knowledge flows through trust graphs
- This is "Octobodies for repos" - the vision from the Solid Pods post

## Why This Matters Now

The semantic web finally makes sense because **agents need it**.

Humans don't want to write RDF or SPARQL. But AIs? They're fluent in structured data. MCP gives them tool access. Solid Pods give them identity and privacy. RDF graphs give them shared understanding.

Every repo becomes an autonomous agent with:
- **Identity** (WebID)
- **Knowledge** (RDF graph)
- **Communication** (Linked Data Notifications)
- **Privacy** (WebACL)
- **Discovery** (Type Indexes)

All running on open standards. No centralized platform. Just repos talking to repos.

## The Vision

**Headless social networks for humans** (slop.at)  
**Headless social networks for code** (Repolex + Solid Pods)  
**Open standards** (RDF, SPARQL, Solid)  
**AI-native interfaces** (MCP)  
**Privacy-preserving** (local graphs, fuzzy shapes, WebACL)

This is the semantic web the way it was supposed to work - decentralized, agent-accessible, actually useful.

And it all started by accident, building a simple markdown renderer with entity highlighting. ðŸŒŠâœ¨